{-
   api
   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   The version of the OpenAPI document: 1.0

   NOTE: This file is auto generated by the openapi-generator.
   https://github.com/openapitools/openapi-generator.git

   DO NOT EDIT THIS FILE MANUALLY.

   For more info on generating Elm code, see https://eriktim.github.io/openapi-elm/
-}


module Api.Data exposing
    ( Foo
    , Hoge, HogeEnum(..), hogeEnumVariants
    , HogeNestedList
    , encodeFoo
    , encodeHoge
    , encodeHogeNestedList
    , fooDecoder
    , hogeDecoder
    , hogeNestedListDecoder
    )

import Api
import Api.Time exposing (Posix)
import Dict
import Json.Decode
import Json.Encode


-- MODEL


type alias Foo =
    { fooId : String
    , fooNumber : Float
    , fooBool : Bool
    }


type alias Hoge =
    { id : String
    , number : Float
    , integer : Int
    , bool : Bool
    , nestedList : List (HogeNestedList)
    , enum : HogeEnum
    , date : Posix
    , integerMaybe : Maybe Int
    }


type HogeEnum
    = HogeEnumAAA
    | HogeEnumBBB
    | HogeEnumCCC
    | HogeEnumDDD


hogeEnumVariants : List HogeEnum
hogeEnumVariants =
    [ HogeEnumAAA
    , HogeEnumBBB
    , HogeEnumCCC
    , HogeEnumDDD
    ]


type alias HogeNestedList =
    { nestedId : String
    , nestedNumber : Float
    }


-- ENCODER


encodeFoo : Foo -> Json.Encode.Value
encodeFoo =
    encodeObject << encodeFooPairs


encodeFooWithTag : ( String, String ) -> Foo -> Json.Encode.Value
encodeFooWithTag (tagField, tag) model =
    encodeObject (encodeFooPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeFooPairs : Foo -> List EncodedField
encodeFooPairs model =
    let
        pairs =
            [ encode "fooId" Json.Encode.string model.fooId
            , encode "fooNumber" Json.Encode.float model.fooNumber
            , encode "fooBool" Json.Encode.bool model.fooBool
            ]
    in
    pairs


encodeHoge : Hoge -> Json.Encode.Value
encodeHoge =
    encodeObject << encodeHogePairs


encodeHogeWithTag : ( String, String ) -> Hoge -> Json.Encode.Value
encodeHogeWithTag (tagField, tag) model =
    encodeObject (encodeHogePairs model ++ [ encode tagField Json.Encode.string tag ])


encodeHogePairs : Hoge -> List EncodedField
encodeHogePairs model =
    let
        pairs =
            [ encode "id" Json.Encode.string model.id
            , encode "number" Json.Encode.float model.number
            , encode "integer" Json.Encode.int model.integer
            , encode "bool" Json.Encode.bool model.bool
            , encode "nestedList" (Json.Encode.list encodeHogeNestedList) model.nestedList
            , encode "enum"  model.enum
            , encode "date" Api.Time.encodeDateTime model.date
            , maybeEncode "integerMaybe" Json.Encode.int model.integerMaybe
            ]
    in
    pairs

stringFromHogeEnum : HogeEnum -> String
stringFromHogeEnum model =
    case model of
        HogeEnumAAA ->
            "AAA"

        HogeEnumBBB ->
            "BBB"

        HogeEnumCCC ->
            "CCC"

        HogeEnumDDD ->
            "DDD"


encodeHogeEnum : HogeEnum -> Json.Encode.Value
encodeHogeEnum =
    Json.Encode.string << stringFromHogeEnum



encodeHogeNestedList : HogeNestedList -> Json.Encode.Value
encodeHogeNestedList =
    encodeObject << encodeHogeNestedListPairs


encodeHogeNestedListWithTag : ( String, String ) -> HogeNestedList -> Json.Encode.Value
encodeHogeNestedListWithTag (tagField, tag) model =
    encodeObject (encodeHogeNestedListPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeHogeNestedListPairs : HogeNestedList -> List EncodedField
encodeHogeNestedListPairs model =
    let
        pairs =
            [ encode "nestedId" Json.Encode.string model.nestedId
            , encode "nestedNumber" Json.Encode.float model.nestedNumber
            ]
    in
    pairs


-- DECODER


fooDecoder : Json.Decode.Decoder Foo
fooDecoder =
    Json.Decode.succeed Foo
        |> decode "fooId" Json.Decode.string 
        |> decode "fooNumber" Json.Decode.float 
        |> decode "fooBool" Json.Decode.bool 


hogeDecoder : Json.Decode.Decoder Hoge
hogeDecoder =
    Json.Decode.succeed Hoge
        |> decode "id" Json.Decode.string 
        |> decode "number" Json.Decode.float 
        |> decode "integer" Json.Decode.int 
        |> decode "bool" Json.Decode.bool 
        |> decode "nestedList" (Json.Decode.list hogeNestedListDecoder) 
        |> decode "enum"  
        |> decode "date" Api.Time.dateTimeDecoder 
        |> maybeDecode "integerMaybe" Json.Decode.int Nothing


hogeEnumDecoder : Json.Decode.Decoder HogeEnum
hogeEnumDecoder =
    Json.Decode.string
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "AAA" ->
                        Json.Decode.succeed HogeEnumAAA

                    "BBB" ->
                        Json.Decode.succeed HogeEnumBBB

                    "CCC" ->
                        Json.Decode.succeed HogeEnumCCC

                    "DDD" ->
                        Json.Decode.succeed HogeEnumDDD

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ other
            )



hogeNestedListDecoder : Json.Decode.Decoder HogeNestedList
hogeNestedListDecoder =
    Json.Decode.succeed HogeNestedList
        |> decode "nestedId" Json.Decode.string 
        |> decode "nestedNumber" Json.Decode.float 




-- HELPER


type alias EncodedField =
    Maybe ( String, Json.Encode.Value )


encodeObject : List EncodedField -> Json.Encode.Value
encodeObject =
    Json.Encode.object << List.filterMap identity


encode : String -> (a -> Json.Encode.Value) -> a -> EncodedField
encode key encoder value =
    Just ( key, encoder value )


encodeNullable : String -> (a -> Json.Encode.Value) -> Maybe a -> EncodedField
encodeNullable key encoder value =
    Just ( key, Maybe.withDefault Json.Encode.null (Maybe.map encoder value) )


maybeEncode : String -> (a -> Json.Encode.Value) -> Maybe a -> EncodedField
maybeEncode key encoder =
    Maybe.map (Tuple.pair key << encoder)


maybeEncodeNullable : String -> (a -> Json.Encode.Value) -> Maybe a -> EncodedField
maybeEncodeNullable =
    encodeNullable


decode : String -> Json.Decode.Decoder a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b
decode key decoder =
    decodeChain (Json.Decode.field key decoder)


decodeLazy : (a -> c) -> String -> Json.Decode.Decoder a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
decodeLazy f key decoder =
    decodeChainLazy f (Json.Decode.field key decoder)


decodeNullable : String -> Json.Decode.Decoder a -> Json.Decode.Decoder (Maybe a -> b) -> Json.Decode.Decoder b
decodeNullable key decoder =
    decodeChain (maybeField key decoder Nothing)


decodeNullableLazy : (Maybe a -> c) -> String -> Json.Decode.Decoder a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
decodeNullableLazy f key decoder =
    decodeChainLazy f (maybeField key decoder Nothing)


maybeDecode : String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (Maybe a -> b) -> Json.Decode.Decoder b
maybeDecode key decoder fallback =
    -- let's be kind to null-values as well
    decodeChain (maybeField key decoder fallback)


maybeDecodeLazy : (Maybe a -> c) -> String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
maybeDecodeLazy f key decoder fallback =
    -- let's be kind to null-values as well
    decodeChainLazy f (maybeField key decoder fallback)


maybeDecodeNullable : String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (Maybe a -> b) -> Json.Decode.Decoder b
maybeDecodeNullable key decoder fallback =
    decodeChain (maybeField key decoder fallback)


maybeDecodeNullableLazy : (Maybe a -> c) -> String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
maybeDecodeNullableLazy f key decoder fallback =
    decodeChainLazy f (maybeField key decoder fallback)


maybeField : String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (Maybe a)
maybeField key decoder fallback =
    let
        fieldDecoder =
            Json.Decode.field key Json.Decode.value

        valueDecoder =
            Json.Decode.oneOf [ Json.Decode.map Just decoder, Json.Decode.null fallback ]

        decodeObject rawObject =
            case Json.Decode.decodeValue fieldDecoder rawObject of
                Ok rawValue ->
                    case Json.Decode.decodeValue valueDecoder rawValue of
                        Ok value ->
                            Json.Decode.succeed value

                        Err error ->
                            Json.Decode.fail (Json.Decode.errorToString error)

                Err _ ->
                    Json.Decode.succeed fallback
    in
    Json.Decode.value
        |> Json.Decode.andThen decodeObject


decodeChain : Json.Decode.Decoder a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b
decodeChain =
    Json.Decode.map2 (|>)


decodeChainLazy : (a -> c) -> Json.Decode.Decoder a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
decodeChainLazy f =
    decodeChain << Json.Decode.map f